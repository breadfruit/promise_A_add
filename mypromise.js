const PENDING ='pending'const FULFILLED = 'fulfilled'const REJECTED = 'rejected'// console.log(this)// {}class mypromise {    constructor(executor) {        //基于事件循环，进行同步任务进行先执行        // console.log(this)        // mypromise        try {            executor(this.resolve, this.reject)        } catch (error) {            this.reject(error)        }    }        states = PENDING        value = null        reason = null        //为啥是数组，因为结果会覆盖        // 存储成功回调函数        onFulfilledCallbacks = [];        // 存储失败回调函数        onRejectedCallbacks = [];        //改变状态        resolve = (value) => {            this.states = FULFILLED            this.value = value            // this.onFulfilledCallbacks && this.onFulfilledCallbacks(this.value)            while (this.onFulfilledCallbacks.length) {                this.onFulfilledCallbacks.shift()(this.value)            }        }        reject = (reason) => {            if (this.states === PENDING) {                this.states = REJECTED                this.reason = reason                // this.onRejectedCallbacks && this.onRejectedCallbacks(this.reason)                while (this.onRejectedCallbacks.length) {                    this.onRejectedCallbacks.shift()(this.reason)                }            }        }        //书写回调函数        then = (onFulfilled, onRejected) => {            const RealonFulfilled = typeof  onFulfilled === 'function' ? onFulfilled : value => value            const RealonRejected = typeof onRejected === 'function' ? onRejected :reason => {throw reason};        //根据状态去执行相应的回调函数        //为什么要加状态判断？        //因为异步函数针对宏任务，我们没有及时修改状态，为了可以让异步函数进行执行            //封装函数            //为了让个个状态都可以进行链式调用，但是发现代码有点冗余            //            const promise = new mypromise((res, rej) => {                const fulfilledMicrotask =()=>{                    queueMicrotask(()=>{                        try{                            const x = RealonFulfilled(this.value)                            resolvePromise(promise,x,res,rej)                        }catch (error){                            rej(error)                        }                    })                }                const rejectedMicrotask =()=>{                    queueMicrotask(()=>{                        try{                            const x = RealonRejected(this.reason)                            resolvePromise(promise,x,res,rej)                        }catch (error){                            rej(error)                        }                    })                }                if (this.states === FULFILLED) {                    fulfilledMicrotask()                }                if (this.states === REJECTED) {                    rejectedMicrotask()                }                if (this.states === PENDING) {                    this.onFulfilledCallbacks.push(fulfilledMicrotask)                    this.onRejectedCallbacks.push(rejectedMicrotask)                }            })            return promise    }        //静态方法只有类本身能调用，实例调用不了        static resolve(param){            //判断参数类型            if(param instanceof mypromise){                return param            }            return new mypromise((res,rej)=>{                res(param)            })        }        static reject (reason) {            return new mypromise((resolve, reject) => {                reject(reason);            });        }}function resolvePromise(promise, x, resolve, reject) {    if (promise === x){        return reject(new TypeError('The promise and the return value are the same'));    }    if(typeof x === 'function' || typeof x === 'object'){        if (x === null){            return resolve(x)        }        let then;        try {            // 把 x.then 赋值给 then            then = x.then;        } catch (error) {            // 如果取 x.then 的值时抛出错误 error ，则以 error 为据因拒绝 promise            return reject(error);        }        if (typeof then === 'function'){            let called = false            try {                  then.call(x,y=> {                      if (called) return                      called = true                      resolvePromise(promise,y,resolve,reject)                  },z=>{                      if (called) return                      called = true                      reject(z)                  })            } catch (e) {                  if(called) return                  reject(e)            }        }else {            resolve(x)        }    }else{        resolve(x)    }}mypromise.deferred = function () {    var result = {};    result.promise = new mypromise(function (resolve, reject) {        result.resolve = resolve;        result.reject = reject;    });    return result;}module.exports = mypromise